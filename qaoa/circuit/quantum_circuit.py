import numpy as np

class QuantumCircuit(object):
    """
    Simulates a quantum circuit formed by a sequence of controlled unitary operators U1,...Un, which are
    generated from Hermitian operators H1,...,Hn. Evalutes the expectation value of the given Hamiltonian
    using control-parameterized states generated by the circuit. 
    """
    def __init__(self,ops,H,psi0=None):

        from qaoa.operators import HermitianOperator  
        from qaoa.circuit import InitialStage, UnitaryStage, TargetStage, link_stages

        self.num_stages = len(ops)
        self.A = [A for A in ops]
        self.A.append(H)

        # Require all operators to be Hermitian
        assert( all( isinstance(A,HermitianOperator) for A in self.A ) )

        # Ensure each stage has the same number of qubits
        nqs = [A.num_qubits() for A in self.A]
        self.num_qubits = nqs[0]
 
        assert( nqs.count(self.num_qubits) == self.num_stages+1 )

        # Number of unique operators 
        self.nu = len({id(A) for A in self.A})

        # Allocate workspace vectors
        #  
        # 1 vector for psi0
        # 1 vector to be shared by Propagators
        # 4 vectors per UnitaryStage (psi,lam,dpsi,dlam)
        # 2 vectors for TargetStage (lam,dlam)

        N = 1 << self.num_qubits
        L = 4*self.num_stages
        self.work = np.zeros((N,L+4),dtype=complex)

        self.psi0 = self.work[:,-1]

#        [A.work.__eq__(self.work[:,-2]) for A in self.A]

        self.psi0[:] = np.ones(N,dtype=complex)/np.sqrt(N) if psi0 is None else psi0

        self.psi  = self.work[:,0:L:4]
        self.lam  = self.work[:,1:L+1:4]
        self.dpsi = self.work[:,2:L+2:4]
        self.dlam = self.work[:,3:L+3:4]

        self.stage = [InitialStage(psi0=self.psi0)]

        [self.stage.append(UnitaryStage(A,  psi=self.psi[:,k],   lam=self.lam[:,k],   \
                                           dpsi=self.dpsi[:,k], dlam=self.dlam[:,k])) \
         for k,A in enumerate(self.A[:-1])]

        self.stage.append(TargetStage(self.A[-1]))#,lam=self.work[:,-2],dlam=self.work[:,-3]))
        link_stages(*self.stage)

    def __len__(self):
        return self.num_stages

    def true_minimum(self):
        """
        Return the true minimum expectation value of this circuit's target operator if possible
        """
        return self.A[-1].true_minimum()

    def true_maximum(self):
        """
        Return the true maximum expectation value of this circuit's target operator if possible
        """
        return self.A[-1].true_maximum()

    def set_control(self,theta):
        """
        Assign control angles to each stage
        """
        assert(len(theta)==self.num_stages)
        [ self.stage[k+1].set_control(theta[k]) for k in range(self.num_stages) ]

    def set_differential_control(self,dtheta):
        """
        Assign differential control angles to each stage
        """
        assert(len(dtheta)==self.num_stages)
        [ self.stage[k+1].set_differential_control(dtheta[k]) \
          for k in range(self.num_stages) ]


    def value(self,theta):
        """
        Compute the objective function at a point theta
        """
        self.set_control(theta)
        return self.A[-1].expectation(self.stage[-2].psi())

    def gradient(self,theta):
        """
        Compute the gradient of the objective function at a point theta
        """
        self.set_control(theta)
        return np.array([self.stage[k+1].deriv_1() \
                         for k in range(self.num_stages)])

    def hessVec(self,theta,dtheta):
        """
        Compute the action of the Hessian matrix evaluated at 
        a point theta on a direction vector dtheta
        """
        self.set_control(theta)
        self.set_differential_control(dtheta)
        return np.array([self.stage[k+1].deriv_2() \
                         for k in range(self.num_stages)])
 
    def hessian(self,theta):
        """
        Evaluate the Hessian matri at a point theta
        """
        self.set_control(theta)
        I = np.eye(self.num_stages)
        return np.array([self.hessVec(theta,e) for e in I])

    def check_gradient(self,theta,delta=1e-4,v=None):
        """
        Compute the error of the gradient with a first-order finite difference approximation
        """
        if v is None:
            v = np.random.rand(self.num_stages) * np.pi

        f0 = self.value(theta)
        g = self.gradient(theta)
        df = np.dot(g,v)
        if hasattr(delta,'__iter__'):
            error = list()
            for h in delta:
                error.append(np.abs(df-(self.value(theta+h*v)-f0)/h))
        else:
            error = np.abs(df - (self.value(theta+delta*v)-f0)/delta)

        return np.array(error) if isinstance(error,list) else error

    def check_hessVec(self,theta,delta=1e-4,v=None):
        """
        Compute the error of the Hessian-Vector product using a first-oeder finite difference approximation
        """   
        if v is None:
            v = np.random.rand(self.num_stages) * np.pi

        g0 = self.gradient(theta)
        Hv = self.hessVec(theta,v)

        if hasattr(delta,'__iter__'):
            error = list()
            for h in delta:
                error.append(np.linalg.norm(Hv-(self.gradient(theta+h*v)-g0)/h))
        else:
            error = np.linalg.norm(Hv-(self.gradient(theta+delta*v)-g0)/delta)

        return np.array(error) if isinstance(error,list) else error

    def compute_psi(self):
        """ 
        Returns the state for each stage. Use for testing purposes only as it is very inefficient
        """ 
        psi = np.zeros((1<<self.num_qubits,self.num_stages+1),dtype=complex)
        psi[:,0] = self.psi0[:]
        for k,s in enumerate(self.stage[1:-1]):
            psi[:,k+1] = s.U.as_matrix() @ psi[:,k]
        return psi[:,1:]
   
    def check_dpsi(self,theta,delta=1e-4,v=None):
        """
        Compute the error of the state sensitivity using a first-order 
        finite difference approximation
        """

        if v is None:
            v = np.random.rand(self.num_stages) * np.pi

        self.set_control(theta)
        self.set_differential_control(v)
        self.stage[-2].psi()
        self.stage[-2].dpsi()
        psi_0 = np.copy(self.psi)
        if hasattr(delta,"__iter__"):
            error = list()
            for h in delta:
                self.set_control(theta+h*v)
                self.stage[-2].psi()
                error.append(np.max(np.abs(self.dpsi-(self.psi-psi_0)/h)))
        else:
           self.set_control(theta+delta*v)
           self.stage[-2].psi()
           error = np.max(np.abs(self.dpsi-(self.psi-psi_0)/delta))
 
        self.set_control(theta)
        return np.array(error) if isinstance(error,list) else error

    def check_dlam(self,theta,delta=1e-4,v=None):
        """
        Compute the error of the adjoint sensitivity using a first-order 
        finite difference approximation
        """

        if v is None:
            v = np.random.rand(self.num_stages) * np.pi

        self.set_control(theta)
        self.set_differential_control(v)
        self.stage[1].lam()
        self.stage[1].dlam()
        lam_0 = np.copy(self.lam)
        if hasattr(delta,"__iter__"):
            error = list()
            for h in delta:
                self.set_control(theta+h*v)
                self.stage[1].lam()
                error.append(np.max(np.abs(self.dlam-(self.lam-lam_0)/h)))
        else:
           self.set_control(theta+delta*v)
           self.stage[1].lam()
           error = np.max(np.abs(self.dlam-(self.lam-lam_0)/delta))
 
        self.set_control(theta)
        return np.array(error) if isinstance(error,list) else error
