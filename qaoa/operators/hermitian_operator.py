from qaoa.operators import LinearOperator, OperatorDocumentation
from qaoa.util.math import inner_product, conj_inner_product
import numpy as np
import abc

class HermitianOperator(LinearOperator):

    """
    Defines the interface of generic Hermitian operators and provides infrastructure used by 
    derived types

    """

    def __str__(self):
        return "HermitianOperator"

    @abc.abstractmethod
    def true_minimum(self):
        """
        Return the minimum eigenvalue of the Hermitian operator
        
        """
        raise NotImplementedError("{0} does not override true_minimum() method".format(str(self))

    @abc.abstractmethod
    def true_maximum(self):
        """
        Return the maximum eigenvalue of the Hermitian operator
        """        
        raise NotImplementedError("{0} does not override true_maximum() method".format(str(self))

    @abc.abstractmethod
    def inner_product(self,u,v):
        """
        Compute the inner product of two vectors using the Hermitian operator

        """
        raise NotImplementedError("{0} does not override method inner_product()".format(str(self)))

    @abc.abstractmethod
    def conj_inner_product(self,u,v):
        """
        Compute the complex-conjugated inner product of two vectors using the Hermitian operator
        """
        raise NotImplementedError("{0} does not override method conj_inner_product()".format(str(self)))

    @abc.abstractmethod
    def expectation(self,v):
        """
        Compute the expectation of this Hermitian operator with the given vector
        
        Returns
        -------
        value : HermitianOperator.dtype
            numpy.dot(numpy.conj(),Av) 
        """
        return np.real(self.conj_inner_product(v,v))

    @abc.abstractmethod
    def propagator(self,theta=0):
        """
        Return the control-parametrized unitary generated by this operator

        Creates a new object of the form U = exp(i*theta*A), where A is the current operator
        """
        from qaoa.operators import Propagator
        return Propagator.create(self,theta)


    def apply_adjoint(self,v,Hv):
        self.apply(v,Hv)

    def apply_adjoint_inverse(self,v,Hv):
        self.apply_inverse(v,Hv)
